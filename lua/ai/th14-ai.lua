sgs.ai_skill_cardask["@baochui"] = function(self, data)	local target = self.room:getCurrent()	if not self:isFriend(target) then return "." end	local cards=self.player:getCards("he")	cards = sgs.QList2Table(cards)	if #cards==0 then return "." end	self:sortByKeepValue(cards) --会导致先扔装备？	return "$" .. cards[1]:getId()endsgs.ai_choicemade_filter.cardResponded["@baochui"] = function(self, player, promptlist)	if promptlist[#promptlist] ~= "_nil_" then		local target = self.room:getCurrent()		if not target then return end			sgs.updateIntention(player, target, -80)	endend--need bear...function SmartAI:yicunEffective(card, to, from)	if not to:hasSkill("yicun")  then return false end	if card:isKindOf("Slash")  then  --or card:isKindOf("Duel")		local id = card:getEffectiveId()		local minus = 0		if id ~=-1 and self.room:getCardPlace(id) == sgs.Player_PlaceHand then			if card:isVirtualCard() then				for _,cd in sgs.qlist(card:getSubcards()) do					if self.room:getCardPlace(cd) == sgs.Player_PlaceHand then						minus = minus + 1					end				end			else				minus = 1			end		end		if from:getHandcardNum() - minus >= to:getHandcardNum() then			return true		end	end	return falseend--function sgs.ai_slash_prohibit.yicun(self, from, to)--function sgs.ai_trick_prohibit.yicun(self, from, to)sgs.ai_skill_playerchosen.moyi = function(self, targets)	for _,target in sgs.qlist(targets) do			if  self:isFriend(target) then			return target		end	end	return nilendsgs.ai_playerchosen_intention.moyi = -30local leiting_skill = {}leiting_skill.name = "leiting"table.insert(sgs.ai_skills, leiting_skill)function leiting_skill.getTurnUseCard(self)    if self.player:hasUsed("leitingCard") then return nil end	return sgs.Card_Parse("@leitingCard=.")endsgs.ai_skill_use_func.leitingCard = function(card, use, self)	local temp	local hearts={}	local spades={}	local cards = self.player:getHandcards()	for _,c in sgs.qlist(cards) do 		if c:getSuit()==sgs.Card_Heart then			table.insert(hearts,c)		elseif c:getSuit()==sgs.Card_Spade then			table.insert(spades,c)		end	end	cards = sgs.QList2Table(cards)	if #cards>0 then		self:sortByKeepValue(cards)		temp= cards[1]		self.player:setTag("temp_leiting",sgs.QVariant(temp:getId()))	end	local slash = sgs.cloneCard("thunder_slash")	if temp and temp:getSuit() == sgs.Card_Spade then		for _,p in pairs (self.friends_noself) do			for _,e in sgs.qlist(self.room:getOtherPlayers(p)) do				if self:isEnemy(e) and p:inMyAttackRange(e) and				p:canSlash(e, slash, true) then					use.card = card					if use.to then						use.to:append(p)						if use.to:length() >= 1 then return end					end				end			end		end	end	if #self.enemies>0 then		self:sort(self.enemies, "hp")		use.card = card		if use.to then			use.to:append(self.enemies[1])            if use.to:length() >= 1 then return end		end	end	use.card = card	if use.to then		local temp_target = self.room:getOtherPlayers(self.player):first()		use.to:append(temp_target)        if use.to:length() >= 1 then return end	endendsgs.ai_skill_playerchosen.leiting = function(self, targets)	local slash = sgs.cloneCard("thunder_slash")	for _,p in pairs (self.enemies) do		if self.player:inMyAttackRange(p) and			self.player:canSlash(p, slash, true) then			return p			end	end	return targets:first()endsgs.ai_skill_cardask["@leiting"] = function(self, data)	local temp =self.player:getTag("temp_leiting"):toInt()	self.player:removeTag("temp_leiting")	if temp then		return "$" .. temp	end	local target =data:toPlayer()	local cards = self.player:getHandcards()	cards = sgs.QList2Table(cards)	self:sortByKeepValue(cards)	return "$" .. cards[1]:getId()endsgs.ai_cardneed.leiting = function(to, card, self)	if not self:willSkipPlayPhase(to) then		return card:getSuit()==sgs.Card_Heart or card:getSuit()==sgs.Card_Spade	endendsgs.ai_skill_invoke.nizhuan =function(self,data)	local use = self.player:getTag("nizhuan_carduse"):toCardUse()	local to=use.to:first()	if to then		return self:isFriend(to)	end	return falseendsgs.ai_choicemade_filter.skillInvoke.nizhuan = function(self, player, promptlist)	local use = player:getTag("nizhuan_carduse"):toCardUse()	local to=use.to:first()	if  to and  promptlist[#promptlist] == "yes" then		sgs.updateIntention(player, to, -80)	endendfunction SmartAI:canNizhuan(player, attacker)	local seija = self.room:findPlayerBySkillName("nizhuan") 	if not player:isWounded() then return false end	if player:getLostHp() <= attacker:getLostHp() then return false end	if seija and self:isFriend(seija,player) and not self:isFriend(player,attacker) and seija:canDiscard(player,"h") then		return true	end	return falseendsgs.ai_skill_cardask["@guizha"] = function(self, data)	for _,card in sgs.qlist(self.player:getCards("h") ) do		if card:isKindOf("Peach") then			return "$" .. card:getId()		end	end	return "." 	endsgs.ai_skill_playerchosen.canxiang = function(self, targets)	for _,p in sgs.qlist(targets) do		if self:isEnemy(p) then			return p		end	endendsgs.ai_choicemade_filter.cardChosen.canxiang = sgs.ai_choicemade_filter.cardChosen.dismantlementsgs.ai_skill_invoke.juwang =function(self,data)	local current = self.room:getCurrent()	return self:isEnemy(current)endsgs.ai_choicemade_filter.skillInvoke.juwang = function(self, player, promptlist)	local current = self.room:getCurrent()	if current and self.player:objectName()~= current:objectName() then		if promptlist[#promptlist] == "yes" then			sgs.updateIntention(player, current, 10)		else			sgs.updateIntention(player, current, -10)		end		endendsgs.ai_skill_playerchosen.yuyin = function(self, targets)	for _,p in sgs.qlist(targets) do		if self:isEnemy(p) then			return p		end	endendsgs.ai_choicemade_filter.cardChosen.yuyin = sgs.ai_choicemade_filter.cardChosen.dismantlementsgs.ai_skill_invoke.wuchang =function(self,data)	local current = self.room:getCurrent()	return self:isEnemy(current)endsgs.ai_choicemade_filter.skillInvoke.wuchang = function(self, player, promptlist)	local current = self.room:getCurrent()	if current then		if promptlist[#promptlist] == "yes" then			sgs.updateIntention(player, current, 10)		end		endendsgs.ai_skill_invoke.langying =function(self,data)	local slash_source	local strs=data:toStringList()	if strs and #strs==2 then 		local str1=(strs[2]:split(":"))[1]		local str2=(strs[2]:split(":"))[2]		if str1=="slash-jink" then			for _,p in sgs.qlist(self.room:getAlivePlayers()) do				if p:objectName() == str2 then					slash_source=p					break				end			end		end	end	if slash_source and self:isFriend(slash_source)	and slash_source:getPhase() == sgs.Player_Play 	and slash_source:hasSkill("sidie")   then		return false	end		local hasDenfense=self.player:getArmor() or self.player:getDefensiveHorse()	if not hasDenfense then		return true	end	local hasJink= self:getCardsNum("Jink") > 0	if not hasJink then		return true	end	local current=self.room:getCurrent()	local enemy_count=0	for _,p in sgs.qlist(self.room:getOtherPlayers(self.player)) do		if not self:isFriend(p) and self:playerGetRound(p) < self:playerGetRound(self.player) 		and self:playerGetRound(current) < self:playerGetRound(p) then			enemy_count=enemy_count+1		end	end	if enemy_count>1 then		return not hasJink	end	return trueendfunction yuanfeiTarget(self)	local targets ={}	for _,p in pairs (self.enemies) do		if (not self.player:inMyAttackRange(p) and not p:isKongcheng()) then			table.insert(targets, p)		end	end	self:sort(targets, "defense")	if #targets > 0 then		return targets[1]	end	return nil endlocal yuanfei_skill = {}yuanfei_skill.name = "yuanfei"table.insert(sgs.ai_skills, yuanfei_skill)function yuanfei_skill.getTurnUseCard(self)    if self.player:hasUsed("yuanfeiCard") or self.player:hasUsed("yuanfeiNearCard")  then return nil end	return sgs.Card_Parse("@yuanfeiCard=.")endsgs.ai_skill_use_func.yuanfeiCard = function(card, use, self)	local target = yuanfeiTarget(self)    if target then    		use.card = card        if use.to then			use.to:append(target)            if use.to:length() >= 1 then return end        end    endendsgs.ai_skill_use_func.yuanfeiNearCard = function(card, use, self)	local cards = self.player:getCards("h")	local yuanfei= sgs.Card_Parse("@yuanfeiNearCard="..cards:first():getEffectiveId())	self:sort(self.enemies, "defense")    for _, p in ipairs(self.enemies) do        if (self.player:inMyAttackRange(p)) then    			use.card = yuanfei            if use.to then				use.to:append(p)                if use.to:length() >= 1 then return end            end		end    endendsgs.ai_use_priority.yuanfeiCard =7sgs.ai_card_intention.yuanfeiCard = 60sgs.ai_card_intention.yuanfeiNearCard = 60sgs.ai_skill_discard.feitou = function(self)	local need_feitou	if self:getOverflow(player)>0 then		need_feitou=true	else		need_feitou= self:getCardsNum("Slash") == 0	end	local to_discard = {}	if not need_feitou then return to_discard end	local cards = self.player:getHandcards()	cards = sgs.QList2Table(cards)	self:sortByKeepValue(cards)	table.insert(to_discard, cards[1]:getEffectiveId())	return to_discardendlocal feitou_skill = {}feitou_skill.name = "feitou"table.insert(sgs.ai_skills, feitou_skill)feitou_skill.getTurnUseCard = function(self, inclusive)		if self.player:getPile("feitou"):isEmpty() then return false end	local ids=self.player:getPile("feitou")	local card= sgs.Sanguosha:getCard(ids:first())	local suit = card:getSuitString()    local number = card:getNumberString()    local card_id = card:getEffectiveId()    local slash_str = ("slash:feitou[%s:%s]=%d"):format(suit, number, card_id)    local slash = sgs.Card_Parse(slash_str)			         assert(slash)    return slashendfunction sgs.ai_cardsview_valuable.feitou(self, class_name, player)	if class_name == "Slash" then		--if (sgs.Sanguosha:getCurrentCardUseReason() ~= sgs.CardUseStruct_CARD_USE_REASON_RESPONSE_USE) then		--	return nil		--end		if self.player:getPile("feitou"):isEmpty() then return nil end		local ids=self.player:getPile("feitou")		local card= sgs.Sanguosha:getCard(ids:first())		local suit = card:getSuitString()        local number = card:getNumberString()        local card_id = card:getEffectiveId()		return ("slash:feitou[%s:%s]=%d"):format(suit, number, card_id)	endendsgs.ai_skill_invoke.shizhu =function(self,data)	return self:getCardsNum("Peach") == 0endsgs.ai_skill_invoke.aige =function(self,data)	local target=data:toPlayer()	return self:isEnemy(target)	endsgs.ai_choicemade_filter.skillInvoke.aige = function(self, player, promptlist)	local to = player:getTag("aige_target"):toPlayer()	if  to and  promptlist[#promptlist] == "yes" then		sgs.updateIntention(player, to, 50)	endendsgs.ai_skill_invoke.jingtao =function(self,data)	local target =self.player:getTag("jingtao_target"):toPlayer()	if self:isEnemy(target) then		return true	else		return false	endendsgs.ai_choicemade_filter.skillInvoke.jingtao = function(self, player, promptlist)	local to = player:getTag("jingtao_target"):toPlayer()	if  to and  promptlist[#promptlist] == "yes" then		sgs.updateIntention(player, to, 50)	endendlocal liange_skill = {}liange_skill.name = "liange"table.insert(sgs.ai_skills, liange_skill)function liange_skill.getTurnUseCard(self)    if self.player:hasUsed("liangeCard") then return nil end    local cards = sgs.QList2Table(self.player:getCards("he"))    if #cards==0 then return nil end	self:sortByKeepValue(cards)	local peach 	for _,c in pairs (cards) do		if c:isKindOf("Peach") then			peach = c			break		end	end	if peach and self.player:hasSkill("shizhu") then		return sgs.Card_Parse("@liangeCard=" .. peach:getEffectiveId())	else		return sgs.Card_Parse("@liangeCard=" .. cards[1]:getEffectiveId())	endendsgs.ai_skill_use_func.liangeCard = function(card, use, self)	local target =self:touhouFindPlayerToDraw(false, 1)	if not target and #self.friends_noself>0 then		target= self.friends_noself[1] 	end	if target then 		use.card = card		if use.to then			use.to:append(target)			if use.to:length() >= 1 then return end		end	endend--sgs.ai_skill_askforag.liange = function(self, card_ids)sgs.ai_use_value.liangeCard = 7sgs.ai_use_priority.liangeCard = sgs.ai_use_priority.Peach + 0.2sgs.ai_card_intention.liangeCard = -70