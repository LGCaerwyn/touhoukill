--【审判】ai--可能需要SmartAI:damageIsEffective(to, nature, from)sgs.ai_skill_playerchosen.ymsndshenpan = function(self, targets)	target_table = self:getEnemies(self.player)	if #target_table==0 then return nil end	self:sort(target_table, "hp")	local shenpan_targets={}--可以摸排	local weak_targets={}--残血	local chain_targets={}--连环效果好	local good_freinds={}--主动电队友	local x,y	for _,target in pairs(target_table) do			if not self:damageIsEffective(target, sgs.DamageStruct_Thunder, self.player) then			continue		end		local damage=sgs.DamageStruct("ymsndshenpan", self.player, target, 1, sgs.DamageStruct_Thunder)				local final_damage=self:touhouDamage(damage,self.player,target)		--能造成伤害是大前提		if final_damage.damage <=0 then continue end				--铁锁		x,y=self:touhouChainDamage(damage,self.player,target)		if x>y then			table.insert(chain_targets,target)		end		--残血敌		if self:isWeak(target)  then			table.insert(weak_targets,target)		end		--审判后可摸排		final_hp= math.max(0,target:getHp()-final_damage.damage)		if target:getHandcardNum()>final_hp  then			table.insert(shenpan_targets,target)		end	end	--电队友	for _,p in pairs (self.friends_noself)do		if p:hasSkill("jingdian") then  			table.insert(good_freinds,p)		end	end	--判断是否必须电人	need_shenpan=true	if self:isWeak(self.player) and self.player:getHandcardNum()<3  	and not self:willSkipPlayPhase(self.player) 	and #weak_targets==0 then 		need_shenpan=false	end	if need_shenpan then		if #weak_targets>0 then			if #chain_targets>0 then				for _,p in pairs(weak_targets) do					if p:isChained() then return p end				end			else				return weak_targets[1]			end		end		if #chain_targets>0 then			if #shenpan_targets>0 then				for _,p in pairs(shenpan_targets) do					if p:isChained() then return p end				end			else				return chain_targets[1]			end		end		if #shenpan_targets>0 then			self:sort(shenpan_targets, "hp")			return shenpan_targets[1]		end		if #good_freinds>0 then			return good_freinds[1]		end	end	return nilendsgs.ai_skill_invoke.ymsndshenpan =truesgs.ai_playerchosen_intention.ymsndshenpan =function(self, from, to)	local intention = 0--有伤害事件修正 可以只更新静电的仇恨	if to:hasSkill("jingdian") then		intention = -30	end	sgs.updateIntention(from, to, intention)end--【悔悟】ai--function SmartAI:getAoeValueTo(card, to, from)function ymsndhuiwu_judge(self,target,card)	--1 悔悟卡牌无效后对目标有利 	--2 悔悟卡牌无效后对目标不利 	--3五谷	if card:isKindOf("AmazingGrace") then		return 3	end	if card:isKindOf("GodSalvation") then 		if target:isWounded() then			return 2		else			return 1		end	end	if card:isKindOf("IronChain") then 		if target:isChained() then			return 2		else			return 1		end	end	if   card:isKindOf("Dismantlement") or card:isKindOf("Snatch") then		if self:isFriend(target) and target:getCards("j"):length()>0 then			return 2		end		if self:isEnemy(target) and target:getCards("j"):length()>0  and target:isNude() then			return 2		end		return 1	end	return 1endsgs.ai_skill_invoke.ymsndhuiwu =function(self,data)	local target=self.player:getTag("ymsndhuiwu"):toPlayer()	local card=self.room:getTag("huiwu_use"):toCardUse().card	--不知道是分析卡牌好坏的函数是哪一个	--先一个个枚举。。。目前只考虑 桃园 铁锁两个例外	--五谷的策略目测很复杂。。。。	if not target then  return false end	local res=ymsndhuiwu_judge(self,target,card)	if res==1 then		return self:isFriend(target)	end	if res==2  then		return self:isEnemy(target)	end	return falseendsgs.ai_choicemade_filter.skillInvoke.ymsndhuiwu = function(self, player, promptlist)	local card=self.room:getTag("huiwu_use"):toCardUse().card	local to=player:getTag("ymsndhuiwu"):toPlayer()	res=ymsndhuiwu_judge(self,to,card)	if res==1 then		if promptlist[#promptlist] == "yes" then			sgs.updateIntention(player, to, -20)		else			sgs.updateIntention(player, to, 20)		end	end	if res==2 then		if promptlist[#promptlist] == "yes" then			sgs.updateIntention(player, to, 20)		else			sgs.updateIntention(player, to, -20)		end	endend--【花冢】aisgs.ai_skill_playerchosen.ymsndhuazhong = function(self, targets)	local canJudge = self:invokeTouhouJudge()	if not canJudge then return nil end	target_table =sgs.QList2Table(targets)	if #target_table==0 then return false end	local huazhong_target	for _,target in pairs(target_table) do			if  self:isFriend(target) then			return target			--break		end	end	return nilendsgs.ai_playerchosen_intention.ymsndhuazhong = -80--【彼岸】ai   use_func有问题？ 大小写问题？？--[[local bian_skill = {}bian_skill.name = "bian"table.insert(sgs.ai_skills, bian_skill)function bian_skill.getTurnUseCard(self)    if self.player:hasUsed("#bian") then return nil end    --if not sgs.Slash_IsAvailable(self.player) then return nil end	local weaker	self:sort(self.enemies,"hp")	for _,p in pairs (self.enemies) do		if self:isWeak(p) then			weaker=p			break		end	end		if not weaker then return nil end	_data=sgs.QVariant()	_data:setValue(weaker)	self.player:setTag("bian_weaker",_data)		--额 还没考虑杀的数量、、、	local handcards = sgs.QList2Table(self.player:getHandcards())    self:sortByUseValue(handcards)	return sgs.Card_Parse("#bian:" .. handcards[1]:getEffectiveId() .. ":")endsgs.ai_skill_use_func["#bian"] = function(card, use, self)	local target=self.player:getTag("bian_weaker"):toPlayer()	self.player:removeTag("bian_weaker")		if target then		use.card = card				if use.to then  --有target却找不到use.to是闹那样。。。						use.to:append(target)			if use.to:length() >= 1 then return end		else				--self.player:drawCards(3)		end	endendsgs.ai_skill_choice.bian="one"]]--【冥途】aisgs.ai_skill_invoke.mingtu = true--【死镰】ai--function SmartAI:hasHeavySlashDamage--【威压】ai 锁定技 不需要--1 修改了cardask[slash-jink] 出闪对策--2修改了sgs.ai_skill_cardask.aoe  打出对策--3修改了function SmartAI:willUsePeachTo(dying)  出桃对策--4修改SmartAI:askForNullification 无懈对策function SmartAI:hasWeiya(player)	player=player or self.player	local current=self.room:getCurrent()	if current and current:isAlive() and current:hasSkill("weiya") then		if player:objectName()== current:objectName() then			return false		end		if not player:hasFlag("weiya_ask") then			return true		end	end	return falseend--【剧毒】aisgs.ai_skill_invoke.judu =function(self,data)	local canJudge = self:invokeTouhouJudge()	if not canJudge then return false end	local target=data:toPlayer()	if self:isEnemy(target) then		return true	endendsgs.ai_choicemade_filter.skillInvoke.judu = function(self, player, promptlist)	--不考虑雷米 天子 两神棍刷牌？？	local damage = self.room:getTag("CurrentDamageStruct"):toDamage()	if promptlist[#promptlist] == "yes" then	sgs.updateIntention(damage.from, damage.to, 70)	endend--【恨意】ai--function SmartAI:getAoeValueTo(card, to, from)--function SmartAI:getAoeValue(card, player)sgs.ai_skill_invoke.henyi =function(self,data)	local card = sgs.Sanguosha:cloneCard("archery_attack", sgs.Card_NoSuit, 0)        	if self:getAoeValue(card, self.player)>0 then  --好这次不保守了		return true	else		return false	endend--【偷拍】aifunction SmartAI:toupaiValue(player)	if self:touhouHandCardsFix(player) or player:hasSkill("heibai") then		return 0	end	local value=0	for _, card in sgs.qlist(player:getHandcards()) do		local flag = string.format("%s_%s_%s", "visible", global_room:getCurrent():objectName(), player:objectName())		if  card:hasFlag("visible") or card:hasFlag(flag) then			if card:isRed() then					value=value+10				if card:isKindOf("BasicCard") then					value=value+20				end				if card:isKindOf("Peach") then					value=value+10				end			end		else			value=value+5		end	end	return valueendsgs.ai_skill_playerchosen.smwwtoupai = function(self, targets)	self:sort(self.enemies,"handcard")	self.enemies = sgs.reverse(self.enemies)	--sort不能直接inverse...	local enemies = self.enemies	for _,p in pairs(self.enemies) do		if self:touhouHandCardsFix(p) or p:hasSkill("heibai") then			table.removeOne(enemies, p)		--elseif p:getHandcardNum()>2  then		--	return p		end	end	if #enemies==0 then return nil end		local compare_func = function(a, b)		return self:toupaiValue(a) > self:toupaiValue(b)	end	table.sort(enemies, compare_func)	if enemies[1] and self:toupaiValue(enemies[1])>=15 then		return enemies[1]	end	return nilend--do gongxin....--【醉月】aisgs.ai_skill_invoke.zuiyue = true--【斗酒】ai--[[相关aiSmartAI:useCardPeachSmartAI:useCardAnaleptic]] function SmartAI:cautionDoujiu(player,card)	player = player or self.player	if player:getPhase() ~=sgs.Player_Play then		return false 	end	local  zhan006 = self.room:findPlayerBySkillName("doujiu")	if not zhan006 	or not self:isEnemy(zhan006)  	or zhan006:isKongcheng() then				return false 	end	--对有【斗酒】的敌人	local enemy_card=self:getMaxCard(zhan006)	local f_card=self:getMaxCard()	local enemy_number=0	local f_number=0	if enemy_card then		enemy_number=enemy_card:getNumber()	end	if f_card then		f_number=f_card:getNumber()	end	if f_number<7 then		if self:getOverflow(player)>0 then			return self:touhouIsPriorUseOtherCard(player,card)		else			return true		end	else		return enemy_number >f_number	end	return falseend--要摸完牌之后用拼点卡。。。该怎么弄。。。sgs.ai_skill_invoke.doujiu =function(self,data)	local target= data:toPlayer()	if self:isEnemy(target) then			if not self.player:isKongcheng() then			self.doujiu_card=  self:getMaxCard():getEffectiveId()			return true		end	endendsgs.ai_choicemade_filter.skillInvoke.doujiu = function(self, player, promptlist)	local target =player:getTag("doujiu_target"):toPlayer()	if target then		if promptlist[#promptlist] == "yes" then			sgs.updateIntention(player, target, 50)		end		endend--被动响应斗酒拼点时，默认拿最大牌function sgs.ai_skill_pindian.doujiu(minusecard, self, requestor, maxcard)	return self:getMaxCard()end--【宴会】ai--ai发动技能和人发动技能时的log不一样。。。local yanhuivs_skill = {}yanhuivs_skill.name = "yanhuivs"table.insert(sgs.ai_skills, yanhuivs_skill)function yanhuivs_skill.getTurnUseCard(self)	if self.player:getKingdom() ~="zhan" then return nil end	local cards = self.player:getHandcards()	local ecards={}	for _,c in sgs.qlist(cards) do		if c:isKindOf("Peach") then			table.insert(ecards,c)		end	end	if #ecards==0 then return nil end		self:sortByKeepValue(ecards)	return sgs.Card_Parse("#yanhuivs:" .. ecards[1]:getEffectiveId() .. ":")	--return sgs.Card_Parse("#yanhuivs:" .. ecards[1]:getEffectiveId() .. ":->" .. target:objectName())endsgs.ai_skill_use_func["#yanhuivs"] = function(card, use, self)	local target		for _,p in sgs.qlist(self.room:getOtherPlayers(self.player)) do        if p:hasLordSkill("yanhui") and p:isAlive() and p:isWounded() then            if self:isFriend(p) then				target=p				break			end        end    end	if not target then return  end	if self.player:isWounded() and target:getHp()>self.player:getHp() then		return 	end		if target then			use.card = card			if use.to then				use.to:append(target)				if use.to:length() >= 1 then return end			end    endendsgs.ai_use_value.yanhuivs = 7sgs.ai_use_priority.yanhuivs = sgs.ai_use_priority.Peach +0.1--濒死出酒的ai 改了源码后 ai还是不起作用...于是暂时保留function sgs.ai_cardsview_valuable.yanhuivs(self, class_name, player)	local acard	if class_name == "Peach" then		local dying = player:getRoom():getCurrentDyingPlayer()		if not dying or not dying:hasLordSkill("yanhui") or self.player:getKingdom() ~="zhan"			or dying:objectName() == player:objectName() then 			return nil 		end				if self:isFriend(dying, player) then 			local cards=player:getCards("h")			for _,c in sgs.qlist(cards) do				if c:isKindOf("Analeptic") then					acard=c					break				end			end		end	end	if acard then		local suit =acard:getSuitString()		local number = acard:getNumberString()		local card_id = acard:getEffectiveId()			return (acard:objectName()..":yanhui[%s:%s]=%d"):format(suit, number, card_id) 	else		return nil	endend--【绯想】ai--sgs.ai_skill_invoke.EightDiagram --sgs.ai_armor_value.EightDiagram --SmartAI:canRetrialsgs.ai_skill_playerchosen.feixiang = function(self, targets)	local judge=self.player:getTag("feixiang_judge"):toJudge()	local card_id =self.player:getTag("feixiang_id"):toInt()	local cards={}	table.insert(cards,judge.card)	local ex_id=self:getRetrialCardId(cards, judge)	--ex_id==-1 说明判定不符合天子的利益	if ex_id ~=-1 then		if judge.reason=="lightning" then			return nil		end	end	--暂时只考虑展示敌人的牌来改判	local new_targets={}	for _,target in sgs.qlist(targets) do		if not target:isKongcheng() and self:isEnemy(target) then			if ex_id== -1 then				table.insert(new_targets,target)			else				local count=0				for _, card in sgs.qlist(target:getHandcards()) do					local flag = string.format("%s_%s_%s", "visible", global_room:getCurrent():objectName(), target:objectName())					if  card:hasFlag("visible") or card:hasFlag(flag) then						local cards1={}						table.insert(cards1,card)						local new_id=self:getRetrialCardId(cards1, judge)						if new_id==-1 then							count=count+1						end					end				end				local rate= count/ target:getHandcardNum()				if rate <= 1/2 then					table.insert(new_targets,target)				end			end		end	end	self:sort(new_targets, "chaofeng")	if #new_targets>0 then		return new_targets[1]	end	return nilend--[[sgs.ai_skill_invoke.feixiang = function(self,data)	local judge=self.player:getTag("feixiang_judge"):toJudge()	local card_id =self.player:getTag("feixiang_id"):toInt()	local card =sgs.Sanguosha:getCard(card_id)	local cards={}	local cards1={}	table.insert(cards,card)	table.insert(cards1,judge.card)	--先要判断新id的好坏	local new_id=self:getRetrialCardId(cards, judge)	local ex_id=self:getRetrialCardId(cards1, judge)	if new_id ~=-1 then		return true	else		if ex_id ==-1 then			return true		else			return false		end	endend]]sgs.ai_playerchosen_intention.feixiang = 50--【地震】aisgs.ai_skill_invoke.dizhen =function(self,data)	local target=self.player:getTag("dizhen_judge"):toJudge().who	if self:isEnemy(target) then		return true	endend--【天人】aisgs.ai_skill_playerchosen.tianren = function(self, targets)	target_table =sgs.QList2Table(targets)	if #target_table==0 then return false end	for _,target in pairs(target_table) do			if  self:isFriend(target) then			return target		end	end	return nilendsgs.ai_playerchosen_intention.tianren = -80--【静电】ai --1 修改了standard_cards-ai.lua里sgs.ai_skill_cardask["slash-jink"]--使得非特殊情况下雷杀不会出闪--2修改smart-ai   damageIsEffective  估计能避免雷属性对着静电使用--一些技巧的补充  没有距离时 雷杀【静电】--function SmartAI:damageIsEffective(to, nature, from)  神诸葛大雾--function SmartAI:needRetrial(judge)--SmartAI:willUseLightning--[[sgs.ai_slash_prohibit.jingdian = function(self, from, to, card)	if self:isFriend(to) then return false end	if not card:isKindOf("ThunderSlash") then return false end	if not self:isFriend(to)and card:isKindOf("ThunderSlash") then return true end	return falseend]]--【雷云】ailocal leiyun_skill = {}leiyun_skill.name = "leiyun"table.insert(sgs.ai_skills, leiyun_skill)leiyun_skill.getTurnUseCard = function(self, inclusive)        local cards = self.player:getCards("h")        cards = sgs.QList2Table(cards)        self:sortByUseValue(cards, true)                local heart_card        for _, card in ipairs(cards) do                if  (card:getSuit()==sgs.Card_Heart or card:getSuit()==sgs.Card_Spade) and  not isCard("Peach", card, self.player) 				and not isCard("ExNihilo", card, self.player) then                        heart_card = card                        break                end        end        if heart_card then                local suit = heart_card:getSuitString()                local number = heart_card:getNumberString()                local card_id = heart_card:getEffectiveId()                local lightning_str = ("lightning:leiyun[%s:%s]=%d"):format(suit, number, card_id)                local lightning = sgs.Card_Parse(lightning_str)                                assert(lightning)                return lightning        endendsgs.leiyun_suit_value = {	spade = 3.9,	heart = 3.9}--【快照】aifunction SmartAI:kuaizhaoValue(player)	if player:isKongcheng() then return 0 end	local value=0	for _, card in sgs.qlist(player:getHandcards()) do		local flag = string.format("%s_%s_%s", "visible", global_room:getCurrent():objectName(), player:objectName())		if  card:hasFlag("visible") or card:hasFlag(flag) then			if card:isKindOf("BasicCard") then				value=value+10			end		else			value=value+5		end	end	return valueend--sgs.ai_skill_invoke.kuaizhao =function(self,data)sgs.ai_skill_playerchosen.kuaizhao = function(self, targets) 	self:sort(self.enemies,"handcard")	local enemies = self.enemies	for _,p in pairs(self.enemies) do		if not self.player:inMyAttackRange(p) 		or p:isKongcheng() then			table.removeOne(enemies, p)		end	end		if #enemies==0 then return nil end	local compare_func = function(a, b)		return self:kuaizhaoValue(a) > self:kuaizhaoValue(b)	end	table.sort(enemies, compare_func)	if enemies[1] and self:kuaizhaoValue(enemies[1])>=15 then		return enemies[1]	end	return nilendsgs.ai_playerchosen_intention.kuaizhao = 80--【短焦】ai 锁定技 不需要sgs.ai_chaofeng.zhan001 = 1sgs.ai_chaofeng.zhan002 = 1sgs.ai_chaofeng.zhan003 = 1sgs.ai_chaofeng.zhan004 = -1sgs.ai_chaofeng.zhan005 = 2sgs.ai_chaofeng.zhan006 = 0sgs.ai_chaofeng.zhan007 = 2sgs.ai_chaofeng.zhan008 = -1sgs.ai_chaofeng.zhan009 = 2